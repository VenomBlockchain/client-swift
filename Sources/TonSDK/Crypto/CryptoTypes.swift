//
//  File.swift
//
//
//  Created by Oleh Hudeichuk on 20.10.2020.
//

import Foundation

//public struct TSDKParamsOfFactorize: Codable {
//    var public var composite: String
//}
//
//public struct TSDKResultOfFactorize: Codable {
//    var public var factors: [String]
//}
//
//public struct TSDKParamsOfModularPower: Codable {
//    var var base: String
//    var var exponent: String
//    var var modulus: String
//}
//
//public struct TSDKResultOfModularPower: Codable {
//    var var modular_power: String
//}

//SigningBoxHandle
typealias TSDKSigningBoxHandle = Int
///Int

//ParamsOfFactorize
public struct TSDKParamsOfFactorize: Codable {
    var composite: String
}
///composite: String – Hexadecimal representation of u64 composite Int.

//ResultOfFactorize
public struct TSDKResultOfFactorize: Codable {
    var factors: [String]
}
///factors: String[] – Two factors of composite or empty if composite can't be factorized.

//ParamsOfModularPower
public struct TSDKParamsOfModularPower: Codable {
    var base: String
    var exponent: String
    var modulus: String
}
///base: String – base argument of calculation.
///exponent: String – exponent argument of calculation.
///modulus: String – modulus argument of calculation.

//ResultOfModularPower
public struct TSDKResultOfModularPower: Codable {
    var modular_power: String
}
///modular_power: String – result of modular exponentiation

//ParamsOfTonCrc16
public struct TSDKParamsOfTonCrc16: Codable {
    var data: String
}
///data: String – Input data for CRC calculation. Encoded with base64.

//ResultOfTonCrc16
public struct TSDKResultOfTonCrc16: Codable {
    var crc: Int
}
///crc: Int – Calculated CRC for input data.

//ParamsOfGenerateRandomBytes
public struct TSDKParamsOfGenerateRandomBytes: Codable {
    var length: Int
}
///length: Int – Size of random byte array.

//ResultOfGenerateRandomBytes
public struct TSDKResultOfGenerateRandomBytes: Codable {
    var bytes: String
}
///bytes: String – Generated bytes encoded with base64.

//ParamsOfConvertPublicKeyToTonSafeFormat
public struct TSDKParamsOfConvertPublicKeyToTonSafeFormat: Codable {
    var public_key: String
}
///public_key: String – Public key.

//ResultOfConvertPublicKeyToTonSafeFormat
public struct TSDKResultOfConvertPublicKeyToTonSafeFormat: Codable {
    var ton_public_key: String
}
///ton_public_key: String – Public key represented in TON safe format.

//KeyPair
public struct TSDKKeyPair: Codable {
    var `public`: String
    var secret: String
}
///public: String – Public key. Encoded with hex.
///secret: String – Private key. Encoded with hex.

//ParamsOfSign
public struct TSDKParamsOfSign: Codable {
    var unsigned: String
    var keys: TSDKKeyPair

    public init(unsigned: String, keys: TSDKKeyPair) {
        self.unsigned = unsigned.isBase64() ? unsigned : (unsigned.base64Encoded() ?? "")
        self.keys = keys
    }
}
///unsigned: String – Data that must be signed.
////keys: KeyPair – Sign keys.

//ResultOfSign
public struct TSDKResultOfSign: Codable {
    var signed: String
    var signature: String

    public init(signed: String, signature: String) {
        self.signed = signed.isBase64() ? signed : (signed.base64Encoded() ?? "")
        self.signature = signature
    }
}
////signed: String – Signed data combined with signature. Encoded with base64.
///signature: String – Signature. Encoded with base64.

//ParamsOfVerifySignature
public struct TSDKParamsOfVerifySignature: Codable {
    var signed: String
    var `public`: String
}
///signed: String – Signed data that must be verified.
///public: String – Signer's public key.

//ResultOfVerifySignature
public struct TSDKResultOfVerifySignature: Codable {
    var unsigned: String
}
///unsigned: String – Unsigned data.

//ParamsOfHash
public struct TSDKParamsOfHash: Codable {
    var data: String

    public init(data: String) {
        self.data = data.isBase64() ? data : (data.base64Encoded() ?? "")
    }
}
///data: String – Input data for hash calculation. Encoded with base64.

//ResultOfHash
public struct TSDKResultOfHash: Codable {
    var hash: String
}
///hash: String – Hex-encoded hash of input data.

//ParamsOfScrypt
public struct TSDKParamsOfScrypt: Codable {
    var password: String
    var salt: String
    var log_n: Int
    var r: Int
    var p: Int
    var dk_len: Int

    public init(password: String, salt: String, log_n: Int, r: Int, p: Int, dk_len: Int) {
        self.password = password.isBase64() ? password : (password.base64Encoded() ?? "")
        self.salt = salt.isBase64() ? salt : (salt.base64Encoded() ?? "")

        self.log_n = log_n
        self.r = r
        self.p = p
        self.dk_len = dk_len
    }
}
///password: String – The password bytes to be hashed.
///salt: String – A salt bytes that modifies the hash to protect against Rainbow table attacks.
///log_n: Int – CPU/memory cost parameter
///r: Int – The block size parameter which fine-tunes sequential memory read size and performance.
///p: Int – Parallelization parameter.
///dk_len: Int – Intended output length in octets of the derived key.

//ResultOfScrypt
public struct TSDKResultOfScrypt: Codable {
    var key: String
}
///key: String – Derived key. Encoded with hex.

//ParamsOfNaclSignKeyPairFromSecret
public struct TSDKParamsOfNaclSignKeyPairFromSecret: Codable {
    var secret: String
}
///secret: String – secret key

//ParamsOfNaclSign
public struct TSDKParamsOfNaclSign: Codable {
    var unsigned: String
    var secret: String

    public init(unsigned: String, secret: String) {
        self.unsigned = unsigned.isBase64() ? unsigned : (unsigned.base64Encoded() ?? "")
        self.secret = secret
    }
}
///unsigned: String – Data that must be signed. Encoded with base64.
///secret: String – Signer's secret key.

//ResultOfNaclSign
public struct TSDKResultOfNaclSign: Codable {
    var signed: String
}
///signed: String – Signed data encoded with base64.

//ParamsOfNaclSignOpen
public struct TSDKParamsOfNaclSignOpen: Codable {
    var signed: String
    var `public`: String

    public init(signed: String, public: String) {
//        self.signed = signed.isBase64() ? signed : (signed.base64Encoded() ?? "")
        self.signed = signed
        self.public = `public`
    }
}
///signed: String – Signed data that must be unsigned. Encoded with base64.
///public: String – Signer's public key.

//ResultOfNaclSignOpen
public struct TSDKResultOfNaclSignOpen: Codable {
    var unsigned: String

    public init(unsigned: String) {
        self.unsigned = unsigned.isBase64() ? unsigned : (unsigned.base64Encoded() ?? "")
    }
}
///unsigned: String – Unsigned data encoded with base64.

//ResultOfNaclSignDetached
public struct TSDKResultOfNaclSignDetached: Codable {
    var signature: String
}
///signature: String – Hex encoded sign.

//ParamsOfNaclBoxKeyPairFromSecret
public struct TSDKParamsOfNaclBoxKeyPairFromSecret: Codable {
    var secret: String
}
///secret: String – Hex encoded secret key.

//ParamsOfNaclBox
public struct TSDKParamsOfNaclBox: Codable {
    var decrypted: String
    var nonce: String
    var their_public: String
    var secret: String

    public init(decrypted: String, nonce: String, their_public: String, secret: String) {
        self.decrypted = decrypted.isBase64() ? decrypted : (decrypted.base64Encoded() ?? "")
        self.nonce = nonce
        self.their_public = their_public
        self.secret = secret
    }
}
///decrypted: String – Data that must be encrypted. Encoded with base64.
///nonce: String
///their_public: String
///secret: String

//ResultOfNaclBox
public struct TSDKResultOfNaclBox: Codable {
    var encrypted: String

    public init(encrypted: String) {
//        self.encrypted = encrypted.isBase64() ? encrypted : (encrypted.base64Encoded() ?? "")
        self.encrypted = encrypted
    }
}
///encrypted: String – Encrypted data. Encoded with base64.

//ParamsOfNaclBoxOpen
public struct TSDKParamsOfNaclBoxOpen: Codable {
    var encrypted: String
    var nonce: String
    var their_public: String
    var secret: String

    public init(encrypted: String, nonce: String, their_public: String, secret: String) {
//        self.encrypted = encrypted.isBase64() ? encrypted : (encrypted.base64Encoded() ?? "")
        self.encrypted = encrypted
        self.nonce = nonce
        self.their_public = their_public
        self.secret = secret
    }
}
///encrypted: String – Data that must be decrypted. Encoded with base64.
///nonce: String
///their_public: String
///secret: String

//ResultOfNaclBoxOpen
public struct TSDKResultOfNaclBoxOpen: Codable {
    var decrypted: String

    public init(decrypted: String) {
        self.decrypted = decrypted.isBase64() ? decrypted : (decrypted.base64Encoded() ?? "")
    }
}
///decrypted: String – Decrypted data. Encoded with base64.

//ParamsOfNaclSecretBox
public struct TSDKParamsOfNaclSecretBox: Codable {
    var decrypted: String
    var nonce: String
    var key: String

    public init(decrypted: String, nonce: String, key: String) {
        self.decrypted = decrypted.isBase64() ? decrypted : (decrypted.base64Encoded() ?? "")
        self.nonce = nonce
        self.key = key
    }
}
///decrypted: String – Data that must be encrypted. Encoded with base64.
///nonce: String
///key: String

//ParamsOfNaclSecretBoxOpen
public struct TSDKParamsOfNaclSecretBoxOpen: Codable {
    var encrypted: String
    var nonce: String
    var key: String

    public init(encrypted: String, nonce: String, key: String) {
//        self.encrypted = encrypted.isBase64() ? encrypted : (encrypted.base64Encoded() ?? "")
        self.encrypted = encrypted
        self.nonce = nonce
        self.key = key
    }
}
///encrypted: String – Data that must be decrypted. Encoded with base64.
///nonce: String
///key: String

//ParamsOfMnemonicWords
public struct TSDKParamsOfMnemonicWords: Codable {
    var dictionary: TSDKMnemonicDictionary?
}
///dictionary?: Int – dictionary identifier

//ResultOfMnemonicWords
public struct TSDKResultOfMnemonicWords: Codable {
    var words: String
}
///words: String – the list of mnemonic words

//ParamsOfMnemonicFromRandom
public struct TSDKParamsOfMnemonicFromRandom: Codable {
    var dictionary: TSDKMnemonicDictionary?
    var word_count: Int?
}
///dictionary?: Int – dictionary identifier
///word_count?: Int – mnemonic word count

//ResultOfMnemonicFromRandom
public struct TSDKResultOfMnemonicFromRandom: Codable {
    var phrase: String
}
///phrase: String – String of mnemonic words

//ParamsOfMnemonicFromEntropy
public struct TSDKParamsOfMnemonicFromEntropy: Codable {
    var entropy: String
    var dictionary: TSDKMnemonicDictionary?
    var word_count: Int?
}
///entropy: String
///dictionary?: Int
///word_count?: Int

//ResultOfMnemonicFromEntropy
public struct TSDKResultOfMnemonicFromEntropy: Codable {
    var phrase: String
}
///phrase: String

//ParamsOfMnemonicVerify
public struct TSDKParamsOfMnemonicVerify: Codable {
    var phrase: String
    var dictionary: TSDKMnemonicDictionary?
    var word_count: Int?
}
///phrase: String – phrase
///dictionary?: Int – dictionary identifier
///word_count?: Int – word count

//ResultOfMnemonicVerify
public struct TSDKResultOfMnemonicVerify: Codable {
    var valid: Bool
}
///valid: boolean – flag indicating the mnemonic is valid or not

//ParamsOfMnemonicDeriveSignKeys
public struct TSDKParamsOfMnemonicDeriveSignKeys: Codable {
    var phrase: String
    var path: String?
    var dictionary: TSDKMnemonicDictionary?
    var word_count: Int?
}
///phrase: String – phrase
///path?: String – derivation path for instance "m/44'/396'/0'/0/0"
///dictionary?: Int – dictionary identifier
///word_count?: Int – word count

//ParamsOfHDKeyXPrvFromMnemonic
public struct TSDKParamsOfHDKeyXPrvFromMnemonic: Codable {
    var phrase: String
}
///phrase: String – String with seed phrase

//ResultOfHDKeyXPrvFromMnemonic
public struct TSDKResultOfHDKeyXPrvFromMnemonic: Codable {
    var xprv: String
}
///xprv: String – serialized extended master private key

//ParamsOfHDKeyDeriveFromXPrv
public struct TSDKParamsOfHDKeyDeriveFromXPrv: Codable {
    var xprv: String
    var child_index: Int
    var hardened: Bool
}
///xprv: String – serialized extended private key
///child_index: Int – child index (see BIP-0032)
///hardened: boolean – indicates the derivation of hardened/not-hardened key (see BIP-0032)

//ResultOfHDKeyDeriveFromXPrv
public struct TSDKResultOfHDKeyDeriveFromXPrv: Codable {
    var xprv: String
}
///xprv: String – serialized extended private key

//ParamsOfHDKeyDeriveFromXPrvPath
public struct TSDKParamsOfHDKeyDeriveFromXPrvPath: Codable {
    var xprv: String
    var path: String
}
///xprv: String – serialized extended private key
///path: String – derivation path for instance "m/44'/396'/0'/0/0"

//ResultOfHDKeyDeriveFromXPrvPath
public struct TSDKResultOfHDKeyDeriveFromXPrvPath: Codable {
    var xprv: String
}
///xprv: String – derived serialized extended private key

//ParamsOfHDKeySecretFromXPrv
public struct TSDKParamsOfHDKeySecretFromXPrv: Codable {
    var xprv: String
}
///xprv: String – serialized extended private key

//ResultOfHDKeySecretFromXPrv
public struct TSDKResultOfHDKeySecretFromXPrv: Codable {
    var secret: String
}
///secret: String – private key

//ParamsOfHDKeyPublicFromXPrv
public struct TSDKParamsOfHDKeyPublicFromXPrv: Codable {
    var xprv: String
}
///xprv: String – serialized extended private key

//ResultOfHDKeyPublicFromXPrv
public struct TSDKResultOfHDKeyPublicFromXPrv: Codable {
    var `public`: String
}

public enum TSDKMnemonicDictionary: Int, Codable {
    case TON = 0
    case ENGLISH = 1
    case CHINESE_SIMPLIFIED = 2
    case CHINESE_TRADITIONAL = 3
    case FRENCH = 4
    case ITALIAN = 5
    case JAPANESE = 6
    case KOREAN = 7
    case SPANISH = 8
}
